// Package compose implements the Docker Compose adapter for the AgentSpec toolchain.
package compose

import (
	"bufio"
	"context"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	"github.com/szaher/designs/agentz/internal/adapters"
	"github.com/szaher/designs/agentz/internal/ir"
)

func init() {
	adapters.Register("docker-compose", func() adapters.Adapter {
		return &Adapter{}
	})
}

// Adapter implements the docker-compose adapter.
type Adapter struct{}

// Name returns the adapter identifier.
func (a *Adapter) Name() string { return "docker-compose" }

// Validate checks whether resources are compatible with Docker Compose.
func (a *Adapter) Validate(_ context.Context, resources []ir.Resource) error {
	return nil
}

// Apply executes the planned actions.
func (a *Adapter) Apply(_ context.Context, actions []adapters.Action) ([]adapters.Result, error) {
	var results []adapters.Result
	for _, action := range actions {
		results = append(results, adapters.Result{
			FQN:    action.FQN,
			Action: action.Type,
			Status: adapters.ResultSuccess,
		})
	}
	return results, nil
}

// Export generates Docker Compose configuration files.
func (a *Adapter) Export(_ context.Context, resources []ir.Resource, outDir string) error {
	if err := os.MkdirAll(filepath.Join(outDir, "config"), 0755); err != nil {
		return err
	}

	var sb strings.Builder
	sb.WriteString("# Generated by agentspec - do not edit\n")
	sb.WriteString("version: \"3.8\"\n\n")
	sb.WriteString("services:\n")

	// Collect environment variables for .env file
	envVars := make(map[string]string)

	for _, r := range resources {
		switch r.Kind {
		case "Agent":
			name := sanitizeName(r.Name)
			fmt.Fprintf(&sb, "  %s:\n", name)
			fmt.Fprintf(&sb, "    container_name: %s\n", name)
			if model, ok := r.Attributes["model"].(string); ok {
				sb.WriteString("    environment:\n")
				fmt.Fprintf(&sb, "      - MODEL=%s\n", model)
				envVars["MODEL"] = model
			}
			sb.WriteString("    volumes:\n")
			fmt.Fprintf(&sb, "      - ./config/%s:/app/config:ro\n", name)
			sb.WriteString("\n")

		case "MCPServer":
			name := sanitizeName(r.Name)
			fmt.Fprintf(&sb, "  %s:\n", name)
			fmt.Fprintf(&sb, "    container_name: %s\n", name)
			if cmd, ok := r.Attributes["command"].(string); ok {
				fmt.Fprintf(&sb, "    command: %s\n", cmd)
			}
			if transport, ok := r.Attributes["transport"].(string); ok {
				if transport == "sse" || transport == "streamable-http" {
					sb.WriteString("    ports:\n")
					sb.WriteString("      - \"8080:8080\"\n")
				}
			}
			sb.WriteString("    volumes:\n")
			fmt.Fprintf(&sb, "      - ./config/%s:/app/config:ro\n", name)
			sb.WriteString("\n")
		}
	}

	// Write docker-compose.yml
	if err := os.WriteFile(filepath.Join(outDir, "docker-compose.yml"), []byte(sb.String()), 0644); err != nil {
		return err
	}

	// Write .env file
	if len(envVars) > 0 {
		var envSB strings.Builder
		envSB.WriteString("# Generated by agentspec - do not edit\n")
		keys := make([]string, 0, len(envVars))
		for k := range envVars {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			fmt.Fprintf(&envSB, "%s=%s\n", k, envVars[k])
		}
		if err := os.WriteFile(filepath.Join(outDir, ".env"), []byte(envSB.String()), 0644); err != nil {
			return err
		}
	}

	return nil
}

// Status returns the status of Docker Compose services.
func (a *Adapter) Status(ctx context.Context) ([]adapters.ResourceStatus, error) {
	cmd := exec.CommandContext(ctx, "docker", "compose", "ps", "--format", "{{.Name}}\t{{.State}}\t{{.Health}}\t{{.Ports}}")
	out, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("docker compose ps: %w", err)
	}

	var statuses []adapters.ResourceStatus
	scanner := bufio.NewScanner(strings.NewReader(string(out)))
	for scanner.Scan() {
		parts := strings.SplitN(scanner.Text(), "\t", 4)
		if len(parts) < 2 {
			continue
		}
		rs := adapters.ResourceStatus{
			FQN:   parts[0],
			Name:  parts[0],
			Kind:  "Container",
			State: parts[1],
		}
		if len(parts) > 2 {
			rs.Health = parts[2]
		}
		if len(parts) > 3 && parts[3] != "" {
			rs.Endpoint = parts[3]
		}
		statuses = append(statuses, rs)
	}
	return statuses, nil
}

// Logs streams Docker Compose logs to the writer.
func (a *Adapter) Logs(ctx context.Context, w io.Writer, opts adapters.LogOptions) error {
	args := []string{"compose", "logs"}
	if opts.Follow {
		args = append(args, "--follow")
	}
	if opts.Tail > 0 {
		args = append(args, "--tail", fmt.Sprintf("%d", opts.Tail))
	}
	if opts.Since != "" {
		args = append(args, "--since", opts.Since)
	}

	cmd := exec.CommandContext(ctx, "docker", args...)
	cmd.Stdout = w
	cmd.Stderr = w
	return cmd.Run()
}

// Destroy tears down Docker Compose services.
func (a *Adapter) Destroy(ctx context.Context) ([]adapters.Result, error) {
	cmd := exec.CommandContext(ctx, "docker", "compose", "down", "--remove-orphans")
	out, err := cmd.CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("docker compose down: %s: %w", string(out), err)
	}
	return []adapters.Result{
		{
			FQN:    "docker-compose/stack",
			Action: adapters.ActionDelete,
			Status: adapters.ResultSuccess,
		},
	}, nil
}

func sanitizeName(name string) string {
	return strings.ReplaceAll(name, " ", "-")
}

// GenerateComposeFromBinaries generates a Docker Compose file for multiple compiled agent binaries.
func GenerateComposeFromBinaries(agents []AgentBinary, networkName string) string {
	var sb strings.Builder
	sb.WriteString("# Generated by agentspec - do not edit\n")
	sb.WriteString("version: \"3.8\"\n\n")
	sb.WriteString("services:\n")

	for _, agent := range agents {
		name := sanitizeName(agent.Name)
		fmt.Fprintf(&sb, "  %s:\n", name)
		fmt.Fprintf(&sb, "    container_name: %s\n", name)
		fmt.Fprintf(&sb, "    image: %s\n", agent.Image)
		sb.WriteString("    ports:\n")
		fmt.Fprintf(&sb, "      - \"%d:%d\"\n", agent.HostPort, agent.ContainerPort)
		sb.WriteString("    environment:\n")
		fmt.Fprintf(&sb, "      - AGENTSPEC_PORT=%d\n", agent.ContainerPort)
		if agent.NoAuth {
			sb.WriteString("      - AGENTSPEC_NO_AUTH=true\n")
		}
		sb.WriteString("    healthcheck:\n")
		fmt.Fprintf(&sb, "      test: [\"CMD\", \"wget\", \"-q\", \"--spider\", \"http://localhost:%d/healthz\"]\n", agent.ContainerPort)
		sb.WriteString("      interval: 10s\n")
		sb.WriteString("      timeout: 3s\n")
		sb.WriteString("      retries: 3\n")

		if networkName != "" {
			sb.WriteString("    networks:\n")
			fmt.Fprintf(&sb, "      - %s\n", networkName)
		}

		sb.WriteString("    restart: unless-stopped\n")
		sb.WriteString("\n")
	}

	if networkName != "" {
		sb.WriteString("networks:\n")
		fmt.Fprintf(&sb, "  %s:\n", networkName)
		sb.WriteString("    driver: bridge\n")
	}

	return sb.String()
}

// AgentBinary describes a compiled agent for Docker Compose packaging.
type AgentBinary struct {
	Name          string
	Image         string
	HostPort      int
	ContainerPort int
	NoAuth        bool
}

// GenerateComposeFile writes a Docker Compose YAML file to the output directory.
func GenerateComposeFile(agents []AgentBinary, outDir, networkName string) error {
	if err := os.MkdirAll(outDir, 0755); err != nil {
		return err
	}

	content := GenerateComposeFromBinaries(agents, networkName)
	return os.WriteFile(filepath.Join(outDir, "docker-compose.yml"), []byte(content), 0644)
}
