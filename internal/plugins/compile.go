package plugins

import (
	"context"
	"encoding/json"
	"fmt"
	"os"

	"github.com/tetratelabs/wazero"
)

// FeatureSupportLevel indicates how well a target supports a given AgentSpec feature.
type FeatureSupportLevel string

const (
	FeatureFull     FeatureSupportLevel = "full"
	FeaturePartial  FeatureSupportLevel = "partial"
	FeatureEmulated FeatureSupportLevel = "emulated"
	FeatureNone     FeatureSupportLevel = "none"
)

// FeatureMap maps AgentSpec feature names to their support level for a target.
type FeatureMap map[string]FeatureSupportLevel

// CompileRequest is the input to a compilation plugin.
type CompileRequest struct {
	IRDocument json.RawMessage `json:"ir_document"`
	OutputDir  string          `json:"output_dir"`
	Name       string          `json:"name"`
}

// CompileResponse is the output of a compilation plugin.
type CompileResponse struct {
	Status   string           `json:"status"`
	Files    []GeneratedFile  `json:"files"`
	Warnings []CompileWarning `json:"warnings,omitempty"`
	Metadata CompileMetadata  `json:"metadata"`
}

// GeneratedFile is a single file generated by a compilation plugin.
type GeneratedFile struct {
	Path    string `json:"path"`
	Content string `json:"content"`
	Mode    string `json:"mode"`
}

// CompileWarning describes a feature gap or limitation for a target.
type CompileWarning struct {
	Feature    string `json:"feature"`
	Message    string `json:"message"`
	Suggestion string `json:"suggestion,omitempty"`
}

// CompileMetadata provides information about the generated project.
type CompileMetadata struct {
	Framework        string `json:"framework"`
	FrameworkVersion string `json:"framework_version"`
	PythonVersion    string `json:"python_version,omitempty"`
	RunCommand       string `json:"run_command"`
}

// CallCompile invokes the compile export of a loaded WASM plugin.
func CallCompile(host *Host, plugin *LoadedPlugin, irJSON []byte, outputDir, name string) (*CompileResponse, error) {
	if plugin.module == nil {
		return nil, fmt.Errorf("plugin %s: no compiled module", plugin.Manifest.Name)
	}

	ctx := context.Background()

	req := CompileRequest{
		IRDocument: irJSON,
		OutputDir:  outputDir,
		Name:       name,
	}
	reqData, err := json.Marshal(req)
	if err != nil {
		return nil, fmt.Errorf("plugin %s: marshal compile request: %w", plugin.Manifest.Name, err)
	}

	config := wazero.NewModuleConfig().
		WithStdout(os.Stdout).
		WithStderr(os.Stderr).
		WithName(fmt.Sprintf("%s-compile", plugin.Manifest.Name))

	mod, err := host.runtime.InstantiateModule(ctx, plugin.module, config)
	if err != nil {
		return nil, fmt.Errorf("plugin %s: instantiate: %w", plugin.Manifest.Name, err)
	}
	defer func() { _ = mod.Close(ctx) }()

	compileFn := mod.ExportedFunction("compile")
	if compileFn == nil {
		return nil, fmt.Errorf("plugin %s: no 'compile' export", plugin.Manifest.Name)
	}

	allocFn := mod.ExportedFunction("alloc")
	if allocFn == nil {
		return nil, fmt.Errorf("plugin %s: no 'alloc' export", plugin.Manifest.Name)
	}

	allocResults, err := allocFn.Call(ctx, uint64(len(reqData)))
	if err != nil {
		return nil, fmt.Errorf("plugin %s: alloc: %w", plugin.Manifest.Name, err)
	}

	ptr := uint32(allocResults[0])
	if !mod.Memory().Write(ptr, reqData) {
		return nil, fmt.Errorf("plugin %s: write memory failed", plugin.Manifest.Name)
	}

	results, err := compileFn.Call(ctx, uint64(ptr), uint64(len(reqData)))
	if err != nil {
		return nil, fmt.Errorf("plugin %s: compile call: %w", plugin.Manifest.Name, err)
	}

	if len(results) < 2 {
		return nil, fmt.Errorf("plugin %s: compile returned unexpected result count", plugin.Manifest.Name)
	}

	resultPtr := uint32(results[0])
	resultSize := uint32(results[1])
	resultData, ok := mod.Memory().Read(resultPtr, resultSize)
	if !ok {
		return nil, fmt.Errorf("plugin %s: read compile result failed", plugin.Manifest.Name)
	}

	var resp CompileResponse
	if err := json.Unmarshal(resultData, &resp); err != nil {
		return nil, fmt.Errorf("plugin %s: unmarshal compile result: %w", plugin.Manifest.Name, err)
	}

	return &resp, nil
}

// CallFeatureSupport invokes the feature_support export of a loaded WASM plugin.
func CallFeatureSupport(host *Host, plugin *LoadedPlugin) (FeatureMap, error) {
	if plugin.module == nil {
		return nil, fmt.Errorf("plugin %s: no compiled module", plugin.Manifest.Name)
	}

	ctx := context.Background()

	config := wazero.NewModuleConfig().
		WithStdout(os.Stdout).
		WithStderr(os.Stderr).
		WithName(fmt.Sprintf("%s-feature-support", plugin.Manifest.Name))

	mod, err := host.runtime.InstantiateModule(ctx, plugin.module, config)
	if err != nil {
		return nil, fmt.Errorf("plugin %s: instantiate: %w", plugin.Manifest.Name, err)
	}
	defer func() { _ = mod.Close(ctx) }()

	fn := mod.ExportedFunction("feature_support")
	if fn == nil {
		return nil, fmt.Errorf("plugin %s: no 'feature_support' export", plugin.Manifest.Name)
	}

	results, err := fn.Call(ctx)
	if err != nil {
		return nil, fmt.Errorf("plugin %s: feature_support call: %w", plugin.Manifest.Name, err)
	}

	if len(results) < 2 {
		return nil, fmt.Errorf("plugin %s: feature_support returned unexpected result count", plugin.Manifest.Name)
	}

	resultPtr := uint32(results[0])
	resultSize := uint32(results[1])
	data, ok := mod.Memory().Read(resultPtr, resultSize)
	if !ok {
		return nil, fmt.Errorf("plugin %s: read feature_support result failed", plugin.Manifest.Name)
	}

	var fm FeatureMap
	if err := json.Unmarshal(data, &fm); err != nil {
		return nil, fmt.Errorf("plugin %s: unmarshal feature map: %w", plugin.Manifest.Name, err)
	}

	return fm, nil
}

// CallVersion invokes the version export of a loaded WASM plugin.
func CallVersion(host *Host, plugin *LoadedPlugin) (string, error) {
	if plugin.module == nil {
		return "", fmt.Errorf("plugin %s: no compiled module", plugin.Manifest.Name)
	}

	ctx := context.Background()

	config := wazero.NewModuleConfig().
		WithStdout(os.Stdout).
		WithStderr(os.Stderr).
		WithName(fmt.Sprintf("%s-version", plugin.Manifest.Name))

	mod, err := host.runtime.InstantiateModule(ctx, plugin.module, config)
	if err != nil {
		return "", fmt.Errorf("plugin %s: instantiate: %w", plugin.Manifest.Name, err)
	}
	defer func() { _ = mod.Close(ctx) }()

	fn := mod.ExportedFunction("version")
	if fn == nil {
		return plugin.Manifest.Version, nil
	}

	results, err := fn.Call(ctx)
	if err != nil {
		return "", fmt.Errorf("plugin %s: version call: %w", plugin.Manifest.Name, err)
	}

	if len(results) < 2 {
		return plugin.Manifest.Version, nil
	}

	resultPtr := uint32(results[0])
	resultSize := uint32(results[1])
	data, ok := mod.Memory().Read(resultPtr, resultSize)
	if !ok {
		return plugin.Manifest.Version, nil
	}

	return string(data), nil
}
